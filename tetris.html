<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8">
    <title>도트 테트리스 게임</title>
    <style>
      body {
        background: #111;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        font-family: 'Consolas', monospace;
      }
      .container {
        display: flex;
        gap: 40px;
      }
      canvas {
        background: #222;
        border: 3px solid #fff;
        image-rendering: pixelated;
        margin-top: 30px;
      }
      .preview {
        background: #222;
        border: 3px solid #fff;
        padding: 16px;
        margin-top: 30px;
        text-align: center;
        width: 128px;
        height: 128px;
      }
      .title {
        color: #fff;
        text-align: center;
        font-size: 2em;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div>
        <div class="title">TETRIS</div>
        <canvas id="game" width="320" height="640"></canvas>
      </div>
      <div>
        <div class="title">NEXT</div>
        <canvas id="next" width="128" height="128" class="preview"></canvas>
      </div>
    </div>
    <script>
      // 도트 크기
      const grid = 32;
      // 모든 테트로미노 형태: 도트 매트릭스
      const tetrominos = {
        'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
        'J': [[1,0,0],[1,1,1],[0,0,0]],
        'L': [[0,0,1],[1,1,1],[0,0,0]],
        'O': [[1,1],[1,1]],
        'S': [[0,1,1],[1,1,0],[0,0,0]],
        'Z': [[1,1,0],[0,1,1],[0,0,0]],
        'T': [[0,1,0],[1,1,1],[0,0,0]],
      };
      // 각 도형 색상
      const colors = {
        'I': '#00FFF7',
        'O': '#FFE900',
        'T': '#D200FF',
        'S': '#00FF36',
        'Z': '#FF0026',
        'J': '#0051FF',
        'L': '#FF9300'
      };
      // 10x20 필드
      const playfield = [];
      for(let row=-2; row<20; row++) {
        playfield[row] = [];
        for(let col=0; col<10; col++) playfield[row][col]=0;
      }
      const canvas = document.getElementById('game');
      const context = canvas.getContext('2d');

      const nextCanvas = document.getElementById('next');
      const nextCtx = nextCanvas.getContext('2d');

      let tetrominoSequence = [];
      function generateSequence() {
        const sequence = ['I','J','L','O','S','T','Z'];
        while(sequence.length){
          const rand = Math.floor(Math.random()*sequence.length);
          tetrominoSequence.push(sequence.splice(rand,1)[0]);
        }
      }
      function getNextTetromino() {
        if(tetrominoSequence.length===0) generateSequence();
        const name = tetrominoSequence.pop();
        const matrix = tetrominos[name];
        const col = Math.floor(playfield[0].length/2)-Math.ceil(matrix[0].length/2);
        const row = name ==='I'? -1 : -2;
        return {name, matrix, row, col};
      }
      // For preview
      function drawNextTetromino(tetro) {
        nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
        const m = tetro.matrix;
        const c = colors[tetro.name];
        const block = grid;
        for(let r=0; r<m.length; r++)
          for(let col=0;col<m[0].length;col++)
            if(m[r][col])
              nextCtx.fillStyle = c,
              nextCtx.fillRect(col*block+block, r*block+block, block-2, block-2);
      }

      let count=0;
      let tetromino = getNextTetromino();
      let nextTetromino = getNextTetromino();
      drawNextTetromino(nextTetromino);
      let rAF=null;
      let gameOver=false;
      function isValidMove(matrix, cellRow, cellCol) {
        for(let row=0;row<matrix.length;row++)
          for(let col=0;col<matrix[row].length;col++)
           if(matrix[row][col]&&(
            cellCol+col<0||
            cellCol+col>=playfield[0].length||
            cellRow+row>=playfield.length||
            playfield[cellRow+row][cellCol+col]
           )) return false;
        return true;
      }
      function rotate(matrix){
        const N = matrix.length-1;
        return matrix.map((row,i)=>
          row.map((val,j)=>matrix[N-j][i])
        );
      }
      function placeTetromino(){
        for(let row=0;row<tetromino.matrix.length;row++)
          for(let col=0;col<tetromino.matrix[row].length;col++)
            if(tetromino.matrix[row][col]){
              // game over if piece has any part offscreen
              if(tetromino.row+row<0) return showGameOver();
              playfield[tetromino.row+row][tetromino.col+col]=tetromino.name;
            }
        // Line clear
        for(let row=playfield.length-1;row>=0;){
          if(playfield[row].every(cell=>!!cell)){
            for(let r=row;r>=0;r--)
              for(let c=0;c<playfield[r].length;c++)
                playfield[r][c]=playfield[r-1][c];
          } else {row--;}
        }
        tetromino = nextTetromino;
        nextTetromino = getNextTetromino();
        drawNextTetromino(nextTetromino);
      }
      function showGameOver() {
        cancelAnimationFrame(rAF);
        gameOver = true;
        context.fillStyle = '#111';
        context.globalAlpha = 0.75;
        context.fillRect(0, canvas.height/2-50, canvas.width, 100);
        context.globalAlpha = 1;
        context.fillStyle = '#fff';
        context.font = '40px Consolas';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText('GAME OVER!', canvas.width/2, canvas.height/2);
      }
      function loop() {
        rAF = requestAnimationFrame(loop);
        context.clearRect(0,0,canvas.width,canvas.height);
        for(let row=0;row<20;row++)
          for(let col=0;col<10;col++)
            if(playfield[row][col]){
              const name=playfield[row][col];
              context.fillStyle=colors[name];
              context.fillRect(col*grid, row*grid, grid-2, grid-2);
            }
        if(tetromino){
          if(++count>35){
            tetromino.row++;
            count=0;
            if(!isValidMove(tetromino.matrix,tetromino.row,tetromino.col)){
              tetromino.row--;
              placeTetromino();
            }
          }
          context.fillStyle = colors[tetromino.name];
          for(let row=0;row<tetromino.matrix.length;row++)
            for(let col=0;col<tetromino.matrix[row].length;col++)
              if(tetromino.matrix[row][col])
                context.fillRect((tetromino.col+col)*grid, (tetromino.row+row)*grid, grid-2, grid-2);
        }
      }
      document.addEventListener('keydown',function(e){
        if(gameOver)return;
        // 좌우 이동
        if(e.which===37||e.which===39){
          const col = e.which===37 ? tetromino.col-1 : tetromino.col+1;
          if(isValidMove(tetromino.matrix,tetromino.row,col))
            tetromino.col = col;
        }
        // 회전
        if(e.which===38){
          const matrix = rotate(tetromino.matrix);
          if(isValidMove(matrix,tetromino.row,tetromino.col))
            tetromino.matrix = matrix;
        }
        // 아래로 이동
        if(e.which===40){
          const row = tetromino.row+1;
          if(!isValidMove(tetromino.matrix,row,tetromino.col)){
            tetromino.row = row-1;
            placeTetromino();
            return;
          }
          tetromino.row = row;
        }
      });
      rAF = requestAnimationFrame(loop);
    </script>
  </body>
</html>
